{
  "title": "Windows API 入門をwindows-rsでやる",
  "closed": false,
  "archived": false,
  "created_at": "2024-09-28",
  "comments": [
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-09-28",
      "body_markdown": "リンク\n\nhttp://kaitei.net/winapi/\n\nhttps://microsoft.github.io/windows-docs-rs/doc/windows/index.html\n\nhttps://microsoft.github.io/windows-rs/features/#/master\n\nrustc 1.79.0\nwindows = \"0.58.0\"\n\n割と適当なので少しずつ改稿していきます。\nまた筆者はrust初心者です。",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-09-28",
      "body_markdown": "# 世界に挨拶\n```rust: main.rs\nuse windows::{\n    core::w,\n    Win32::UI::WindowsAndMessaging::{MessageBoxW, MB_OK},\n};\n\nfn main() {\n    unsafe {\n        MessageBoxW(None, w!(\"Hello, world!\"), w!(\"Test\"), MB_OK);\n    }\n}\n\n```\n```rust: main.rs\nuse windows::{\n    core::w,\n    Win32::UI::WindowsAndMessaging::{MessageBoxW, MB_ICONEXCLAMATION, MB_OK, MB_YESNOCANCEL},\n};\n\nfn main() {\n    unsafe {\n        MessageBoxW(\n            None,\n            w!(\"変更を保存しますか？\"),\n            w!(\"メモ帳\"),\n            MB_YESNOCANCEL | MB_ICONEXCLAMATION,\n        );\n    }\n}\n\n```"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-09-28",
      "body_markdown": "|macro|type|\n|-|-|\n|h!|HSTRING|\n|s!|PCSTR|\n|w!|PCWSTR|\n\n意味はまだよくわかっていない。\npはポインタ、cは定数(const)、wはワイド、hはハンドルとだけ認識している。\nたぶんこれ\nhttp://kaitei.net/winapi/data-types/\n:::details ハンドルとは\nプログラムやファイルに割り当てられるポインタ。\n```c\nFILE *fp = fopen(\"hoge.txt\", \"r\");\n```\nのfpのこと(らしい)\n:::",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-09-28",
      "body_markdown": "# メッセージボックス \n```rust: main.rs\nuse windows::{\n    core::w,\n    Win32::UI::WindowsAndMessaging::{\n        MessageBoxW, IDCANCEL, IDOK, MB_ICONINFORMATION, MB_ICONQUESTION, MB_OKCANCEL,\n    },\n};\n\nfn main() {\n    unsafe {\n        let id = MessageBoxW(\n            None,\n            w!(\"ボタンを押してください\"),\n            w!(\"\"),\n            MB_OKCANCEL | MB_ICONQUESTION,\n        );\n\n        match id {\n            IDOK => MessageBoxW(\n                None,\n                w!(\"[OK]が押されました.\"),\n                w!(\"結果\"),\n                MB_ICONINFORMATION,\n            ),\n            IDCANCEL => MessageBoxW(\n                None,\n                w!(\"[キャンセル]が押されました.\"),\n                w!(\"結果\"),\n                MB_ICONINFORMATION,\n            ),\n            _ => return,\n        };\n    }\n}\n\n```\n```rust :main.rs\nuse windows::{\n    core::w,\n    Win32::{\n        Foundation::HINSTANCE,\n        UI::WindowsAndMessaging::{MessageBoxIndirectW, MB_ICONASTERISK, MB_OK, MSGBOXPARAMSW},\n    },\n};\n\nfn main() {\n    unsafe {\n        let mbp = MSGBOXPARAMSW {\n            cbSize: std::mem::size_of::<MSGBOXPARAMSW>() as u32,\n            hInstance: HINSTANCE::default(),\n            lpszCaption: w!(\"Test\"),\n            lpszText: w!(\"Hello, world!\"),\n            dwStyle: MB_OK | MB_ICONASTERISK,\n            ..Default::default()\n        };\n        MessageBoxIndirectW(&mbp);\n    }\n}\n\n```\nhinstanceにとりあえずdefault入れといたけどこれどうしたらいいんだろ。\nこれならほかの設定項目と一緒にまとめとけばよかったかなとは思う。",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-09-30",
      "body_markdown": "メッセージボックスを選ぶ前に消える。\n:::details コード\n```rust :main.rs\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        let hwnd = CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        // ウィンドウの表示\n        let _ = ShowWindow(hwnd, SHOW_WINDOW_CMD::default());\n        // ウィンドウの再描画\n        let _ = UpdateWindow(hwnd);\n        // ストッパーになるらしいがならない\n        MessageBoxW(hwnd, w!(\"ウィンドウを生成しました.\"), w!(\"\"), MB_OK);\n\n        Ok(())\n    }\n}\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        match message {\n            WM_PAINT => {\n                println!(\"WM_PAINT\");\n                _ = ValidateRect(window, None);\n                LRESULT(0)\n            }\n            WM_DESTROY => {\n                println!(\"WM_DESTROY\");\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n\n```\n:::\n:::details 修正版\nなぜか動いた．原理はよく理解していない．showwindow, updatewindowはいらなそう．\n```rust :main.rs\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        let hwnd = CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        MessageBoxW(hwnd, w!(\"ウィンドウを生成しました.\"), w!(\"\"), MB_OK);\n\n        Ok(())\n    }\n}\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        match message {\n            WM_PAINT => {\n                println!(\"WM_PAINT\");\n                _ = ValidateRect(window, None);\n                LRESULT(0)\n            }\n            WM_DESTROY => {\n                println!(\"WM_DESTROY\");\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n\n```\n:::",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-09-30",
      "body_markdown": "スケルトンプログラム。\n:::details コード\n```rust :main.rs\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        let mut msg = MSG::default();\n\n        while GetMessageW(&mut msg, None, 0, 0).into() {\n            let _ = TranslateMessage(&msg);\n            DispatchMessageW(&msg);\n        }\n\n        Ok(())\n    }\n}\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        match message {\n            WM_PAINT => {\n                println!(\"WM_PAINT\");\n                _ = ValidateRect(window, None);\n                LRESULT(0)\n            }\n            WM_DESTROY => {\n                println!(\"WM_DESTROY\");\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n\n```\n:::",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-09-30",
      "body_markdown": "終了時に確認\n:::details コード\n```rust :main.rs\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        let mut msg = MSG::default();\n\n        while GetMessageW(&mut msg, None, 0, 0).into() {\n            let _ = TranslateMessage(&msg);\n            DispatchMessageW(&msg);\n        }\n\n        Ok(())\n    }\n}\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        match message {\n            WM_PAINT => {\n                println!(\"WM_PAINT\");\n                _ = ValidateRect(window, None);\n                LRESULT(0)\n            }\n            WM_CLOSE => {\n                let id = MessageBoxW(\n                    window,\n                    w!(\"終了しますか\"),\n                    w!(\"終了\"),\n                    MB_YESNO | MB_ICONEXCLAMATION,\n                );\n                if id == IDYES {\n                    if let Err(e) = DestroyWindow(window) {\n                        panic!(\"{}\", e);\n                    }\n                }\n                println!(\"WM_CLOSE\");\n                LRESULT(0)\n            }\n            WM_DESTROY => {\n                println!(\"WM_DESTROY\");\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n\n```\n:::"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-09-30",
      "body_markdown": "# WM_CREATE メッセージで獲得できる情報をメッセージボックスに表示\nめちゃめちゃ難産だった。ただcx、cyの値がおかしいし色々不安というか怪しい。とりあえず進む。\n:::details コード\n```rust :main.rs\nuse std::mem::transmute;\n\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        let mut msg = MSG::default();\n\n        while GetMessageW(&mut msg, None, 0, 0).into() {\n            let _ = TranslateMessage(&msg);\n            DispatchMessageW(&msg);\n        }\n\n        Ok(())\n    }\n}\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        match message {\n            WM_CREATE => {\n                let lpcs: &CREATESTRUCTW = transmute(lparam);\n                let title = format!(\n                    \"lpszClass: {}\\nlpszName: {}\\nx: {}\\ny: {}\\ncx: {}\\ncy: {}\",\n                    lpcs.lpszClass.to_string().unwrap(),\n                    lpcs.lpszName.to_string().unwrap(),\n                    lpcs.x,\n                    lpcs.y,\n                    lpcs.cx,\n                    lpcs.cy\n                );\n                let mut title = title.encode_utf16().collect::<Vec<_>>();\n                title.push(0);\n\n                MessageBoxW(\n                    window,\n                    PCWSTR::from_raw(title.as_ptr()),\n                    w!(\"WM_CREATE\"),\n                    MB_OK,\n                );\n                LRESULT(0)\n            }\n            WM_DESTROY => {\n                println!(\"WM_DESTROY\");\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n\n```\n:::",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-09-30",
      "body_markdown": "# ウィンドウの移動の表示\n:::details コード\n```rust :main.rs\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        let mut msg = MSG::default();\n\n        while GetMessageW(&mut msg, None, 0, 0).into() {\n            let _ = TranslateMessage(&msg);\n            DispatchMessageW(&msg);\n        }\n\n        Ok(())\n    }\n}\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        match message {\n            WM_PAINT => {\n                println!(\"WM_PAINT\");\n                _ = ValidateRect(window, None);\n                LRESULT(0)\n            }\n            WM_DESTROY => {\n                println!(\"WM_DESTROY\");\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            WM_MOVE => {\n                let x = lparam.0 & 0xffff;\n                let y = (lparam.0 >> 16) & 0xffff;\n                let title = format!(\"WM_MOVE ({}, {})\", x, y);\n                let _ = SetWindowTextW(\n                    window,\n                    PCWSTR::from_raw(\n                        title\n                            .encode_utf16()\n                            .chain(::std::iter::once(0))\n                            .collect::<Vec<u16>>()\n                            .as_mut_ptr(),\n                    ),\n                );\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n\n```\n:::"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-09-30",
      "body_markdown": "# ウィンドウのサイズの表示\nソースコードはほぼ同じ\n:::details コード\n``` rust :main.rs\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        let mut msg = MSG::default();\n\n        while GetMessageW(&mut msg, None, 0, 0).into() {\n            let _ = TranslateMessage(&msg);\n            DispatchMessageW(&msg);\n        }\n\n        Ok(())\n    }\n}\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        match message {\n            WM_DESTROY => {\n                println!(\"WM_DESTROY\");\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            WM_SIZE => {\n                let cx = lparam.0 & 0xffff;\n                let cy = (lparam.0 >> 16) & 0xffff;\n                let title = format!(\"WM_SIZE ({}, {})\", cx, cy);\n                let _ = SetWindowTextW(\n                    window,\n                    PCWSTR::from_raw(\n                        title\n                            .encode_utf16()\n                            .chain(::std::iter::once(0))\n                            .collect::<Vec<u16>>()\n                            .as_mut_ptr(),\n                    ),\n                );\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n\n```\n:::"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-09-30",
      "body_markdown": "# マウスの入力の検知\nマウスのキーアップ、キーダウン、移動の表示\n:::details コード\n```rust :main.rs\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        let mut msg = MSG::default();\n\n        while GetMessageW(&mut msg, None, 0, 0).into() {\n            let _ = TranslateMessage(&msg);\n            DispatchMessageW(&msg);\n        }\n\n        Ok(())\n    }\n}\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        match message {\n            WM_DESTROY => {\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            WM_MOUSEMOVE => {\n                let x = lparam.0 & 0xffff;\n                let y = (lparam.0 >> 16) & 0xffff;\n                let msg = format!(\"WM_MOUSEMOVE ({}, {})\", x, y);\n                let _ = SetWindowTextW(\n                    window,\n                    PCWSTR::from_raw(\n                        msg.encode_utf16()\n                            .chain(::std::iter::once(0))\n                            .collect::<Vec<u16>>()\n                            .as_mut_ptr(),\n                    ),\n                );\n                LRESULT(0)\n            }\n            WM_LBUTTONDOWN => {\n                let x = lparam.0 & 0xffff;\n                let y = (lparam.0 >> 16) & 0xffff;\n                let msg = format!(\"WM_LBUTTONDOWN ({}, {})\", x, y);\n                let _ = SetWindowTextW(\n                    window,\n                    PCWSTR::from_raw(\n                        msg.encode_utf16()\n                            .chain(::std::iter::once(0))\n                            .collect::<Vec<u16>>()\n                            .as_mut_ptr(),\n                    ),\n                );\n                LRESULT(0)\n            }\n            WM_LBUTTONUP => {\n                let x = lparam.0 & 0xffff;\n                let y = (lparam.0 >> 16) & 0xffff;\n                let msg = format!(\"WM_LBUTTONUP ({}, {})\", x, y);\n                let _ = SetWindowTextW(\n                    window,\n                    PCWSTR::from_raw(\n                        msg.encode_utf16()\n                            .chain(::std::iter::once(0))\n                            .collect::<Vec<u16>>()\n                            .as_mut_ptr(),\n                    ),\n                );\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n\n```\n:::",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-10-02",
      "body_markdown": "# ウィンドウの移動\n:::details コード\n```rust :main.\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        let mut msg = MSG::default();\n\n        while GetMessageW(&mut msg, None, 0, 0).into() {\n            let _ = TranslateMessage(&msg);\n            DispatchMessageW(&msg);\n        }\n\n        Ok(())\n    }\n}\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        match message {\n            WM_MOVE => {\n                let x = lparam.0 & 0xffff;\n                let y = (lparam.0 >> 16) & 0xffff;\n                let mut text = format!(\"WM_MOVE ({}, {})\", x, y)\n                    .encode_utf16()\n                    .collect::<Vec<_>>();\n                text.push(0);\n                if let Err(e) = SetWindowTextW(window, PCWSTR::from_raw(text.as_ptr())) {\n                    panic!(\"{}\", e);\n                }\n                LRESULT(0)\n            }\n            WM_DESTROY => {\n                println!(\"WM_DESTROY\");\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n\n```\n:::"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-10-02",
      "body_markdown": "# ウィンドウのサイズの変更\n:::details コード\n```rust :main.rs\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        let mut msg = MSG::default();\n\n        while GetMessageW(&mut msg, None, 0, 0).into() {\n            let _ = TranslateMessage(&msg);\n            DispatchMessageW(&msg);\n        }\n\n        Ok(())\n    }\n}\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        match message {\n            WM_SIZE => {\n                let cx = lparam.0 & 0xffff;\n                let cy = (lparam.0 >> 16) & 0xffff;\n                let mut text = format!(\"WM_SIZE ({}, {})\", cx, cy)\n                    .encode_utf16()\n                    .collect::<Vec<_>>();\n                text.push(0);\n                if let Err(e) = SetWindowTextW(window, PCWSTR::from_raw(text.as_ptr())) {\n                    panic!(\"{}\", e);\n                }\n                LRESULT(0)\n            }\n            WM_DESTROY => {\n                println!(\"WM_DESTROY\");\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n\n```\n:::"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-10-02",
      "body_markdown": "# マウス入力\n:::details コード\n```rust :main.rs\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        let mut msg = MSG::default();\n\n        while GetMessageW(&mut msg, None, 0, 0).into() {\n            let _ = TranslateMessage(&msg);\n            DispatchMessageW(&msg);\n        }\n\n        Ok(())\n    }\n}\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        match message {\n            WM_MOUSEMOVE => {\n                let x = lparam.0 & 0xffff;\n                let y = (lparam.0 >> 16) & 0xffff;\n                let mut text = format!(\"WM_MOUSEMOVE ({}, {})\", x, y)\n                    .encode_utf16()\n                    .collect::<Vec<_>>();\n                text.push(0);\n                if let Err(e) = SetWindowTextW(window, PCWSTR::from_raw(text.as_ptr())) {\n                    panic!(\"{}\", e);\n                }\n                LRESULT(0)\n            }\n            WM_LBUTTONDOWN => {\n                let x = lparam.0 & 0xffff;\n                let y = (lparam.0 >> 16) & 0xffff;\n                let mut text = format!(\"WM_LBUTTONDOWN ({}, {})\", x, y)\n                    .encode_utf16()\n                    .collect::<Vec<_>>();\n                text.push(0);\n                if let Err(e) = SetWindowTextW(window, PCWSTR::from_raw(text.as_ptr())) {\n                    panic!(\"{}\", e);\n                }\n                LRESULT(0)\n            }\n            WM_LBUTTONUP => {\n                let x = lparam.0 & 0xffff;\n                let y = (lparam.0 >> 16) & 0xffff;\n                let mut text = format!(\"WM_LBUTTONUP ({}, {})\", x, y)\n                    .encode_utf16()\n                    .collect::<Vec<_>>();\n                text.push(0);\n                if let Err(e) = SetWindowTextW(window, PCWSTR::from_raw(text.as_ptr())) {\n                    panic!(\"{}\", e);\n                }\n                LRESULT(0)\n            }\n            WM_DESTROY => {\n                println!(\"WM_DESTROY\");\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n```\n:::"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-10-02",
      "body_markdown": "# キーボード入力\n:::details コード\n```rust :main.rs\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        let mut msg = MSG::default();\n\n        while GetMessageW(&mut msg, None, 0, 0).into() {\n            let _ = TranslateMessage(&msg);\n            DispatchMessageW(&msg);\n        }\n\n        Ok(())\n    }\n}\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        match message {\n            WM_KEYDOWN => {\n                let vkey = wparam.0;\n                let text = format!(\"WM_KEYDOWN (vkey: {})\", vkey);\n                let _ = SetWindowTextW(\n                    window,\n                    PCWSTR::from_raw(\n                        text.encode_utf16()\n                            .chain(::std::iter::once(0))\n                            .collect::<Vec<_>>()\n                            .as_ptr(),\n                    ),\n                );\n                LRESULT(0)\n            }\n            WM_KEYUP => {\n                let vkey = wparam.0;\n                let text = format!(\"WM_KEYUP (vkey: {})\", vkey);\n                let _ = SetWindowTextW(\n                    window,\n                    PCWSTR::from_raw(\n                        msg.encode_utf16()\n                            .chain(::std::iter::once(0))\n                            .collect::<Vec<u16>>()\n                            .as_ptr(),\n                    ),\n                );\n                LRESULT(0)\n            }\n            WM_DESTROY => {\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n\n```\n:::"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-10-02",
      "body_markdown": "# 四角形の描画\n:::details コード\n```rust :main.rs\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        let mut msg = MSG::default();\n\n        while GetMessageW(&mut msg, None, 0, 0).into() {\n            let _ = TranslateMessage(&msg);\n            DispatchMessageW(&msg);\n        }\n\n        Ok(())\n    }\n}\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        let hdc;\n        let mut ps = PAINTSTRUCT::default();\n\n        match message {\n            WM_PAINT => {\n                hdc = BeginPaint(window, &mut ps);\n                let _ = Rectangle(hdc, 50, 50, 200, 150);\n                let _ = EndPaint(window, &mut ps);\n                LRESULT(0)\n            }\n            WM_DESTROY => {\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n\n```\n:::",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "o_p_h_i_s",
      "created_at": "2024-10-02",
      "body_markdown": "# 描画の無効化\n:::details コード\n```rust :main.rs\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::*, Graphics::Gdi::*, System::LibraryLoader::*, UI::WindowsAndMessaging::*,\n    },\n};\n\nfn main() -> Result<()> {\n    unsafe {\n        // ウィンドウクラスの属性の設定\n        let app_name = w!(\"TestApp\");\n\n        let instance = GetModuleHandleW(None)?;\n\n        let wc = WNDCLASSW {\n            style: CS_HREDRAW | CS_VREDRAW,\n            lpfnWndProc: Some(wndproc),\n            cbClsExtra: 0,\n            cbWndExtra: 0,\n            hInstance: instance.into(),\n            hIcon: LoadIconW(None, IDI_APPLICATION)?,\n            hCursor: LoadCursorW(None, IDC_ARROW)?,\n            hbrBackground: GetSysColorBrush(COLOR_WINDOW),\n            lpszMenuName: w!(\"\"),\n            lpszClassName: app_name,\n        };\n\n        // ウィンドウクラスの登録\n        debug_assert!(RegisterClassW(&wc) != 0);\n\n        // ウィンドウの作成\n        CreateWindowExW(\n            WINDOW_EX_STYLE::default(),\n            app_name,\n            w!(\"Title\"),\n            WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            CW_USEDEFAULT,\n            None,\n            None,\n            instance,\n            None,\n        )?;\n\n        let mut msg = MSG::default();\n\n        while GetMessageW(&mut msg, None, 0, 0).into() {\n            let _ = TranslateMessage(&msg);\n            DispatchMessageW(&msg);\n        }\n\n        Ok(())\n    }\n}\n\nstatic mut X: i32 = 0;\nstatic mut Y: i32 = 0;\n\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {\n    unsafe {\n        let hdc;\n        let mut ps = PAINTSTRUCT::default();\n\n        match message {\n            WM_LBUTTONDOWN => {\n                X = (lparam.0 & 0xffff) as i32;\n                Y = ((lparam.0 >> 16) & 0xffff) as i32;\n                let _ = InvalidateRect(window, None, true);\n                LRESULT(0)\n            }\n            WM_PAINT => {\n                hdc = BeginPaint(window, &mut ps);\n                let _ = Rectangle(hdc, X - 10, Y - 10, X + 10, Y + 10);\n                let _ = EndPaint(window, &mut ps);\n                LRESULT(0)\n            }\n            WM_DESTROY => {\n                PostQuitMessage(0);\n                LRESULT(0)\n            }\n            _ => DefWindowProcW(window, message, wparam, lparam),\n        }\n    }\n}\n\n```\n:::"
    }
  ]
}